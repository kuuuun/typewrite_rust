<!DOCTYPE HTML>
<html lang="cjk" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Typewrite of Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html"> 介绍 </a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">速查</li><li class="spacer"></li><li class="chapter-item expanded "><a href="ch01/var_binding.html"><strong aria-hidden="true">1.</strong>  变量绑定和解构 </a></li><li class="chapter-item expanded "><a href="ch02/basic_type.html"><strong aria-hidden="true">2.</strong>  基本类型 </a></li><li class="chapter-item expanded "><a href="ch03/complex_type.html"><strong aria-hidden="true">3.</strong>  复合类型 </a></li><li class="chapter-item expanded "><a href="ch04/flow_control.html"><strong aria-hidden="true">4.</strong>  流程控制 </a></li><li class="chapter-item expanded "><a href="ch05/pattern_matching.html"><strong aria-hidden="true">5.</strong>  模式匹配 </a></li><li class="chapter-item expanded "><a href="ch06/method.html"><strong aria-hidden="true">6.</strong>  方法 </a></li><li class="chapter-item expanded "><a href="ch07/generics_and_traits.html"><strong aria-hidden="true">7.</strong>  泛型和特征 </a></li><li class="chapter-item expanded "><a href="ch08/collections.html"><strong aria-hidden="true">8.</strong>  集合类型 </a></li><li class="chapter-item expanded "><a href="ch09/lifetimes.html"><strong aria-hidden="true">9.</strong>  认识生命周期 </a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Typewrite of Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="typewrite-of-rust"><a class="header" href="#typewrite-of-rust">Typewrite of Rust</a></h1>
<p>Rust 语法格式速查</p>
<p>参考:</p>
<ul>
<li><em>Rust 语言圣经</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-变量绑定与解构"><a class="header" href="#1-变量绑定与解构">1. 变量绑定与解构</a></h2>
<h3 id="11-变量绑定"><a class="header" href="#11-变量绑定">1.1 变量绑定</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 5;
let b:i32 = 5;
let mut c = 6;
<span class="boring">}</span></code></pre></pre>
<h3 id="12-下划线开头忽略使用的变量"><a class="header" href="#12-下划线开头忽略使用的变量">1.2 下划线开头忽略使用的变量</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _x = 5;   // _x 不要净高未使用的变量，也是临时变量
<span class="boring">}</span></code></pre></pre>
<h3 id="13-变量解构"><a class="header" href="#13-变量解构">1.3 变量解构</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (mut e, f): (bool, bool) = (true, false);
<span class="boring">}</span></code></pre></pre>
<h3 id="14-解构式赋值"><a class="header" href="#14-解构式赋值">1.4 解构式赋值</a></h3>
<p><strong><code>+=</code></strong> 不支持</p>
<pre><pre class="playground"><code class="language-rust">struct Struct {
  e:i32
}
fn main() {
  let (a, b, c, d, e);
  (a, b) = (1, 2);
  [_, c, .., d, _] = [1,2,3,4,5];
  Struct {e,..} = Struct {e: 5};

  assert_eq!([1,2,2,4,5], [a,b,c,d,e]);
}</code></pre></pre>
<h3 id="15-变量和常量的区别"><a class="header" href="#15-变量和常量的区别">1.5 变量和常量的区别</a></h3>
<p>没有mut，没有let</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS:u32 = 10_0000;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="2-基本类型"><a class="header" href="#2-基本类型">2. 基本类型</a></h2>
<ul>
<li>数值类型:
<ul>
<li><strong>有符号整数</strong> (i8, i16, i32, i64, isize)</li>
<li><strong>无符号整数</strong> (u8, u16, u32, u64, usize)</li>
<li><strong>浮点数</strong> (f32, f64)</li>
<li>有理数</li>
<li>复数</li>
</ul>
</li>
<li><strong>字符串</strong>：
<ul>
<li>字符串字面量</li>
<li>字符串切片 &amp;str</li>
</ul>
</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()</li>
</ul>
<h3 id="21-函数"><a class="header" href="#21-函数">2.1 函数</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(i:i32,j:i32) -&gt; i32{
  i + j
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="3-复合类型"><a class="header" href="#3-复合类型">3. 复合类型</a></h2>
<h3 id="31-字符串"><a class="header" href="#31-字符串">3.1 字符串</a></h3>
<h4 id="311-字符串和切片字符串字面量"><a class="header" href="#311-字符串和切片字符串字面量">3.1.1 字符串和切片(字符串字面量)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 中文在 UTF-8 中占用三个字节
// 切片的本质是指针
let s = String::from(&quot;hello world&quot;);
let sentence = String::from(&quot;你好,世界&quot;);
let a = [1,2,3,4,5];

let hello = &amp;s[0..5];
let world = &amp;s[6..11];

assert_eq!(&amp;s[0..5], &amp;s[..5]);
assert_eq!(&amp;s, &amp;s[..]);
assert!(&amp;s[0..6]);  // 需要是3的倍数，否则报错
assert_eq!(&amp;a[1..3], [2, 3]);
<span class="boring">}</span></code></pre></pre>
<h4 id="312-操作字符串"><a class="header" href="#312-操作字符串">3.1.2 操作字符串</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>s.push_str(&quot;追加字符串&quot;);
s.insert(5,'插入字符');
s.replace(&quot;rust&quot;, &quot;RUST&quot;);
s.replacen(&quot;rust&quot;, &quot;RUST&quot;, 1);  // index
s.replace_range(0..5, &quot;RUST&quot;);

// 删除字符串
s.pop();    // 从后往前pop
s.remove(0);    // index

s.truncate(5);  // 从指定位置到结尾，截断
s.clear();      // 清空
let s = &quot;hello&quot;.to_string()+&quot; &quot;+&quot;world&quot;;    
// String = String1 + &amp;str + &amp;str... String1所有权转移！
<span class="boring">}</span></code></pre></pre>
<h4 id="313-操作utf-8字符串"><a class="header" href="#313-操作utf-8字符串">3.1.3 操作UTF-8字符串</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;中国人&quot;.chars(){}
<span class="boring">}</span></code></pre></pre>
<h3 id="32-元祖"><a class="header" href="#32-元祖">3.2 元祖</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup:(i32, f64, u8) = (500, 6.4, 1);
<span class="boring">}</span></code></pre></pre>
<h4 id="321-模式匹配解构元祖"><a class="header" href="#321-模式匹配解构元祖">3.2.1 模式匹配解构元祖</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, z) = tup;
<span class="boring">}</span></code></pre></pre>
<h4 id="322-用--来访问元组"><a class="header" href="#322-用--来访问元组">3.2.2 用 . 来访问元组</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let five_hundred = tup.0;
let six_point_four = tup.1;
let one = tup.2;
<span class="boring">}</span></code></pre></pre>
<h3 id="33-结构体"><a class="header" href="#33-结构体">3.3 结构体</a></h3>
<h4 id="331-结构体语法"><a class="header" href="#331-结构体语法">3.3.1 结构体语法</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定义结构体
// 结构体数据存在堆上, 实际是指针
struct User {
  active: bool,
  username: String,
  email: String,
  sign_in_count: u64,
}

// 实例化
let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

// 访问结构体的成员
user1.email = String::from(&quot;anotheremail@example.com&quot;);

// 结构体更新语法
let user2 = User {
      email: String::from(&quot;another@example.com&quot;),
      ..user1
};
<span class="boring">}</span></code></pre></pre>
<h4 id="332-元祖结构体"><a class="header" href="#332-元祖结构体">3.3.2 元祖结构体</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
let black = Color(0, 0, 0);
<span class="boring">}</span></code></pre></pre>
<h4 id="333-单元结构体"><a class="header" href="#333-单元结构体">3.3.3 单元结构体</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AlwaysEqual;

let subject = AlwaysEqual;

// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {}
<span class="boring">}</span></code></pre></pre>
<h4 id="334-结构体数据的所有权"><a class="header" href="#334-结构体数据的所有权">3.3.4 结构体数据的所有权</a></h4>
<pre><pre class="playground"><code class="language-rust">// 因为我们想要这个结构体拥有它所有的数据，而不是从其它地方借用数据。
// 你也可以让 User 结构体从其它对象借用数据，不过这么做，就需要引入生命周期(lifetimes)这个新概念
struct User&lt;'a&gt; {
    username: &amp;'a str,
    email: &amp;'a str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}</code></pre></pre>
<h4 id="335-使用derivedebug-来打印结构体的信息"><a class="header" href="#335-使用derivedebug-来打印结构体的信息">3.3.5 使用<code>#[derive(Debug)]</code> 来打印结构体的信息</a></h4>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
    // 还有一个简单的输出 debug 信息的方法，那就是使用 dbg! 宏，
    // 它会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，
    // 当然还有我们需要的表达式的求值结果。除此之外，它最终还会把表达式值的所有权返回!
    dbg!(&amp;rect1);
}</code></pre></pre>
<pre><code class="language-text">$ cargo run
rect1 is Rectangle { width: 30, height: 50 }

$ cargo run
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &amp;rect1 = Rectangle {
    width: 60,
    height: 50,
}
</code></pre>
<blockquote>
<p>dbg! 输出到标准错误输出 stderr，而 println! 输出到标准输出 stdout。</p>
</blockquote>
<h3 id="34-枚举"><a class="header" href="#34-枚举">3.4 枚举</a></h3>
<h4 id="341-枚举语法"><a class="header" href="#341-枚举语法">3.4.1 枚举语法</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}

let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 用struct的带值的枚举
enum PokerSuit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}

struct PokerCard {
    suit: PokerSuit,
    value: u8
}

fn main() {
   let c1 = PokerCard {
       suit: PokerSuit::Clubs,
       value: 1,
   };
   let c2 = PokerCard {
       suit: PokerSuit::Diamonds,
       value: 12,
   };
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 带值的枚举，优于上面代码
enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
}

fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds(13);
}</code></pre></pre>
<h4 id="342-option枚举用于处理空值"><a class="header" href="#342-option枚举用于处理空值">3.4.2 Option枚举用于处理空值</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 因为 Option，Some，None 都包含在 prelude 中，因此你可以直接通过名称来使用它们，
// 而无需以 Option::Some 这种形式去使用，总之，千万不要因为调用路径变短了，
// 就忘记 Some 和 None也是 Option 底下的枚举成员！
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}</span></code></pre></pre>
<h3 id="35-数组"><a class="header" href="#35-数组">3.5 数组</a></h3>
<ul>
<li><strong>速度很快但是长度固定</strong>的 array，称为<strong>数组</strong>。</li>
<li><strong>可动态增长的但是有性能损耗</strong>的 Vector，称为<strong>动态数组</strong>。</li>
</ul>
<h4 id="351-创建数组"><a class="header" href="#351-创建数组">3.5.1 创建数组</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
let a:[i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<h4 id="352-访问数组"><a class="header" href="#352-访问数组">3.5.2 访问数组</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
let first = a[0];
let second = a[1];
<span class="boring">}</span></code></pre></pre>
<h4 id="353-数组元素为非基础类型"><a class="header" href="#353-数组元素为非基础类型">3.5.3 数组元素为非基础类型</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// String 未实现 Copy, 不能实现[String; 8]的赋值方式
// 须使用 std::array::from_fn
let array: [String; 8] = std::array::from_fn(|_i| String::from(&quot;rust is good!&quot;));
println!(&quot;{:#?}&quot;, array);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
  // 编译器自动推导出one的类型
  let one             = [1, 2, 3];
  // 显式类型标注
  let two: [u8; 3]    = [1, 2, 3];
  let blank1          = [0; 3];
  let blank2: [u8; 3] = [0; 3];

  // arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]
  let arrays: [[u8; 3]; 4]  = [one, two, blank1, blank2];

  // 借用arrays的元素用作循环中
  for a in &amp;arrays {
    print!(&quot;{:?}: &quot;, a);
    // 将a变成一个迭代器，用于循环
    // 你也可以直接用for n in a {}来进行循环
    for n in a.iter() {
      print!(&quot;\t{} + 10 = {}&quot;, n, n+10);
    }

    let mut sum = 0;
    // 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1
    // 可以用for_each来进行循环 a.iter().for_each(|n| sum += n);
    for i in 0..a.len() {
      sum += a[i];
    }
    println!(&quot;\t({:?} = {})&quot;, a, sum);
  }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="4-流程控制"><a class="header" href="#4-流程控制">4. 流程控制</a></h2>
<h3 id="41-使用if来做分支控制"><a class="header" href="#41-使用if来做分支控制">4.1 使用if来做分支控制</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}</code></pre></pre>
<h3 id="42-使用else-if来处理多重条件"><a class="header" href="#42-使用else-if来处理多重条件">4.2 使用<code>else if</code>来处理多重条件</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let n = 6;

    if n % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if n % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if n % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}</code></pre></pre>
<h3 id="43-for循环"><a class="header" href="#43-for循环">4.3 for循环</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果还想继续使用container，可以使用&amp;和&amp;mut
for item in &amp;container {
  // ...
}

for item in &amp;mut collection {
  // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 获得数组中每个元素的索引
fn main() {
    let a = [4, 3, 2, 1];
    // `.iter()` 方法把 `a` 数组变成一个迭代器
    for (i, v) in a.iter().enumerate() {
        println!(&quot;第{}个元素是{}&quot;, i + 1, v);
    }
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 运行10次
for _ in 0..10 {
  // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="44-continue和break"><a class="header" href="#44-continue和break">4.4 continue和break</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 continue 可以跳过当前当次的循环，开始下次的循环：
 for i in 1..4 {
     if i == 2 {
         continue;
     }
     println!(&quot;{}&quot;, i); // output: 1 3
 }
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 break 可以直接跳出当前整个循环：
 for i in 1..4 {
     if i == 2 {
         break;
     }
     println!(&quot;{}&quot;, i); // output: 1
 }
<span class="boring">}</span></code></pre></pre>
<h3 id="45-while循环"><a class="header" href="#45-while循环">4.5 while循环</a></h3>
<pre><pre class="playground"><code class="language-rust">// 如果你需要一个条件来循环，当该条件为 true 时，继续循环，条件为 false，跳出循环，那么 while 就非常适用：
fn main() {
    let mut n = 0;

    while n &lt;= 5  {
        println!(&quot;{}!&quot;, n);

        n = n + 1;
    }

    println!(&quot;我出来了！&quot;);
}</code></pre></pre>
<h3 id="46-loop循环"><a class="header" href="#46-loop循环">4.6 loop循环</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    // loop 是一个表达式，因此可以返回一个值
    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;  // break 可以单独使用，也可以带一个返回值，有些类似 return
        }
    };

    println!(&quot;The result is {}&quot;, result);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="5-模式匹配"><a class="header" href="#5-模式匹配">5. 模式匹配</a></h2>
<h3 id="51-match和if-let"><a class="header" href="#51-match和if-let">5.1 match和if let</a></h3>
<h4 id="511-匹配模式-match和if-let"><a class="header" href="#511-匹配模式-match和if-let">5.1.1 匹配模式: match和if let</a></h4>
<pre><pre class="playground"><code class="language-rust">enum Direction {
    East,
    West,
    North,
    South,
}

// 模式匹配最常用的就是 match 和 if let
fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::North | Direction::South =&gt; {
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(&quot;West&quot;),
    };
}</code></pre></pre>
<h4 id="512-使用-match-表达式赋值"><a class="header" href="#512-使用-match-表达式赋值">5.1.2 使用 match 表达式赋值</a></h4>
<pre><pre class="playground"><code class="language-rust">enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    // match 本身也是一个表达式，因此可以用它来赋值
    let ip_str = match ip1 {
        IpAddr::Ipv4 =&gt; &quot;127.0.0.1&quot;,
        _ =&gt; &quot;::1&quot;,
    };

    println!(&quot;{}&quot;, ip_str);
}</code></pre></pre>
<h4 id="513-模式绑定"><a class="header" href="#513-模式绑定">5.1.3 模式绑定</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState), // 25美分硬币
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        // 内部存储的值绑定到了 state 变量上，因此 state 变量就是对应的 UsState 枚举类型。
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say(&quot;Hello Rust&quot;.to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) =&gt; {
                println!(&quot;{}&quot;, s);
            },
            Action::MoveTo(x, y) =&gt; {
                println!(&quot;point from (0, 0) move to ({}, {})&quot;, x, y);
            },
            Action::ChangeColorRGB(r, g, _) =&gt; {
                println!(&quot;change color into '(r:{}, g:{}, b:0)', 'b' has been ignored&quot;,
                    r, g,
                );
            }
        }
    }
}</code></pre></pre>
<h4 id="514-穷尽匹配"><a class="header" href="#514-穷尽匹配">5.1.4 穷尽匹配</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let number = 42;
    match number{
        0 =&gt; println!(&quot;Origin&quot;),
        1...3 =&gt; println!(&quot;All&quot;),
        |5|7|13| =&gt; println!(&quot;Bad Luck&quot;),
        n @ 42 =&gt; println!(&quot;Answer is {}&quot;, n),
        _ =&gt; println!(&quot;Common&quot;),
    }
}</code></pre></pre>
<h4 id="515-if-let匹配"><a class="header" href="#515-if-let匹配">5.1.5 if let匹配</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 只有一种情况的匹配,适合使用 if let
if let Some(3) = v {
    println!(&quot;three&quot;);
}

// match 需要穷尽匹配
let v = Some(3u8);
match v {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="516-matches宏"><a class="header" href="#516-matches宏">5.1.6 matches!宏</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = 'f';
assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

let bar = Some(4);
assert!(matches!(bar, Some(x) if x &gt; 2));

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let mut count = 0;

    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
    for e in v {
        if matches!(e, MyEnum::Foo) {
            count += 1;
        }
    }
    assert_eq!(count, 2);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];

    for a in v.iter().filter(|x| matches!(x, MyEnum::Foo)){
        println!(&quot;{:?}&quot;, a);
    }
}</code></pre></pre>
<h4 id="517-变量遮蔽"><a class="header" href="#517-变量遮蔽">5.1.7 变量遮蔽</a></h4>
<pre><pre class="playground"><code class="language-rust">// 在if let 中，= 右边 Some(i32) 类型的 age 被左边 i32 类型的新 age 遮蔽了，该遮蔽一直持续到 if let 语句块的结束。
// 因此第三个 println! 输出的 age 依然是 Some(i32) 类型。
fn main() {
   let age = Some(30);
   println!(&quot;在匹配前，age是{:?}&quot;,age);
    // 尽量不用用同名,避免难以理解, 比如用x
   if let Some(age) = age {
       println!(&quot;匹配出来的age是{}&quot;,age);
   }x

   println!(&quot;在匹配后，age是{:?}&quot;,age);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
   let age = Some(30);
   println!(&quot;在匹配前，age是{:?}&quot;,age);
   match age {
        // 尽量不用用同名,避免难以理解, 比如用x
       Some(age) =&gt;  println!(&quot;匹配出来的age是{}&quot;,age),
       _ =&gt; ()
   }
   println!(&quot;在匹配后，age是{:?}&quot;,age);
}</code></pre></pre>
<h3 id="52-解构option"><a class="header" href="#52-解构option">5.2 解构Option</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Option 值的存在; Result 错误的存在
fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

// Option 实现了Copy, 会move
let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);

// unwrap解包Some()里包含的值
let six = six.unwrap();
<span class="boring">}</span></code></pre></pre>
<h3 id="53-全模式列表"><a class="header" href="#53-全模式列表">5.3 全模式列表</a></h3>
<h4 id="531-匹配字面量"><a class="header" href="#531-匹配字面量">5.3.1 匹配字面量</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 匹配字面量
let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="532-匹配命名变量"><a class="header" href="#532-匹配命名变量">5.3.2 匹配命名变量</a></h4>
<pre><pre class="playground"><code class="language-rust">// 匹配命名变量
fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}</code></pre></pre>
<h4 id="533-单分支多模式"><a class="header" href="#533-单分支多模式">5.3.3 单分支多模式</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 单分支多模式
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="534-通过序列--匹配值的范围"><a class="header" href="#534-通过序列--匹配值的范围">5.3.4 通过序列 ..= 匹配值的范围</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 通过序列 ..= 匹配值的范围
let x = 5;

match x {
    1..=5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}

// 另外一个例子
let x = 'c';

match x {
    'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="535-结构并分解值"><a class="header" href="#535-结构并分解值">5.3.5 结构并分解值</a></h4>
<h5 id="解构结构体"><a class="header" href="#解构结构体">解构结构体</a></h5>
<pre><pre class="playground"><code class="language-rust">// 解构并分解值
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    let Point { x, y } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
    assert_eq!(0, x);
    assert_eq!(7, y);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 结构匹配
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}</code></pre></pre>
<h5 id="解构枚举"><a class="header" href="#解构枚举">解构枚举</a></h5>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}</code></pre></pre>
<h5 id="解构嵌套的结构体和枚举"><a class="header" href="#解构嵌套的结构体和枚举">解构嵌套的结构体和枚举</a></h5>
<pre><pre class="playground"><code class="language-rust">enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(
                &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
                h,
                s,
                v
            )
        }
        _ =&gt; ()
    }
}</code></pre></pre>
<h5 id="解构结构体和元组"><a class="header" href="#解构结构体和元组">解构结构体和元组</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
     x: i32,
     y: i32,
 }

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}</span></code></pre></pre>
<h5 id="解构数组"><a class="header" href="#解构数组">解构数组</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 定长数组
let arr: [u16; 2] = [114, 514];
let [x, y] = arr;

assert_eq!(x, 114);
assert_eq!(y, 514);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不定长数组
let arr: &amp;[u16] = &amp;[114, 514];

if let [x, ..] = arr {
    assert_eq!(x, &amp;114);
}

if let &amp;[.., y] = arr {
    assert_eq!(y, 514);
}

let arr: &amp;[u16] = &amp;[];

assert!(matches!(arr, [..]));   // [..] 就是个空数组
assert!(!matches!(arr, [x, ..]));   // x is not in scope
<span class="boring">}</span></code></pre></pre>
<h4 id="536-忽略模式中的值"><a class="header" href="#536-忽略模式中的值">5.3.6 忽略模式中的值</a></h4>
<h5 id="使用-_-忽略整个值"><a class="header" href="#使用-_-忽略整个值">使用 _ 忽略整个值</a></h5>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}</code></pre></pre>
<h5 id="用--忽略剩余值"><a class="header" href="#用--忽略剩余值">用 .. 忽略剩余值</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="537-匹配守卫提供的额外条件"><a class="header" href="#537-匹配守卫提供的额外条件">5.3.7 匹配守卫提供的额外条件</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="54-绑定"><a class="header" href="#54-绑定">5.4 @绑定</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10..=12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
<span class="boring">}</span></code></pre></pre>
<h4 id="541-前绑定后解构rust-156-新增"><a class="header" href="#541-前绑定后解构rust-156-新增">5.4.1 @前绑定后解构(Rust 1.56 新增)</a></h4>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // 绑定新变量 `p`，同时对 `Point` 进行解构
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!(&quot;x: {}, y: {}&quot;, px, py);
    println!(&quot;{:?}&quot;, p);


    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!(&quot;x is 10 and y is {} in {:?}&quot;, y, p);
    } else {
        println!(&quot;x was not 10 :(&quot;);
    }
}</code></pre></pre>
<h4 id="542-新特性rust-153-新增"><a class="header" href="#542-新特性rust-153-新增">5.4.2 @新特性(Rust 1.53 新增)</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    match 1 {
        num @ (1 | 2) =&gt; {
            println!(&quot;{}&quot;, num);
        }
        _ =&gt; {}
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="6-方法method"><a class="header" href="#6-方法method">6. 方法Method</a></h2>
<h3 id="61-定义方法"><a class="header" href="#61-定义方法">6.1 定义方法</a></h3>
<pre><pre class="playground"><code class="language-rust">struct Circle {
        x: f64,
        y: f64,
        radius: f64,
}

impl Circle {
    // new是Circle的关聀函数，因为它的第一个参数不是self，且new并不是关键字
    // 这种方法往往用于初始化当前结构体的实例
    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
        Circle {
                x: x,
                y: y,
                radius: radius,
        }
    }
    // NOTE: 方法和字段名相同，往往适用于getter访问器
    fn radius(&amp;self) -&gt; f64 {
        self.radius
    }

    // NOTE:*self*: 表示所有权借用到该方法中，用的较少
    // NOTE:*&amp;self*: 表示该方法对结构体的不可变借用
    // NOTE:*&amp;mut self*: 表示该方法对结构体的可变借用
    // NOTE:*Self*: 表示结构体类型，也就是Circle
    //
    // Circle的方法，&amp;self表示借用当前的Circle结构体
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.)
    }
}

fn main(){
    let circle = Circle::new(0.0, 0.0, 5.0);

    // NOTE: Rust有一个自动引用和解引用的功能。方法调用是少数几个拥有这种行为的地方。
    // p1.distance(&amp;p2);
    // (&amp;p1).distance(&amp;p2);
    println!(&quot;{}&quot;, circle.radius());
}</code></pre></pre>
<h3 id="62-带有多个参数的方法"><a class="header" href="#62-带有多个参数的方法">6.2 带有多个参数的方法</a></h3>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
struct Rectangle{
    width:u32,
    height:u32,
}

impl Rectangle {
    // 构造函数，可简化结构体初始化
    fn new(w: u32, h: u32) -&gt; Rectangle {
        Rectangle { width: w, height: h }
    }

    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    // &amp;Rectangle == &amp;Self, 不拿所有权
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    // let rect1 = Rectangle { width: 30, height: 50 };
    let rect1 = Rectangle::new(30, 50);
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}</code></pre></pre>
<h3 id="63-关联函数"><a class="header" href="#63-关联函数">6.3 关联函数</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rectangle {
    // 构造函数，可简化结构体初始化
    fn new(w: u32, h: u32) -&gt; Rectangle {
        Rectangle { width: w, height: h }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="64-多个impl定义"><a class="header" href="#64-多个impl定义">6.4 多个impl定义</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 用于演示，实际不用
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="65-为枚举实现方法"><a class="header" href="#65-为枚举实现方法">6.5 为枚举实现方法</a></h3>
<pre><pre class="playground"><code class="language-rust">// NOTE: 枚举强大，在于它好用，可以同一化类型，还可以像结构一样实现方法。
#![allow(unused)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // 在这里定义方法体
        match &amp;self {
            Message::Write(str) =&gt; {println!(&quot;Write string is {}&quot;, str);},
            _ =&gt; {println!(&quot;no message in Message::Write()&quot;);},
        }
    }
}

fn main() {
    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();   // output: Write string is &quot;hello&quot;
    let n = Message::Quit;
    n.call();   // output: no message in Message::Write()
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="7-泛型和特征"><a class="header" href="#7-泛型和特征">7. 泛型和特征</a></h2>
<h3 id="71-泛型generics"><a class="header" href="#71-泛型generics">7.1 泛型Generics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 泛型会增加编译时间，增加最后编译文件的大小。
<span class="boring">}</span></code></pre></pre>
<h4 id="711-泛型详解"><a class="header" href="#711-泛型详解">7.1.1 泛型详解</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 函数 largest 有泛型类型 T，它有个参数 list，其类型是元素为 T 的数组切片，最后，该函数返回值的类型也是 T。
fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// where 的用法
fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T
where T: PartialOrd + Copy {
    let mut largest = list[0];  // 增加了Copy trait, 允许复制

    for &amp;item in list {     // list是一个数组切片，&amp;item是一个元素
        if item &gt; largest {     // 增加了PartialOrd trait，允许比较
            largest = item;     // item的类型是T，可以复制
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}</code></pre></pre>
<h4 id="712-结构体的泛型"><a class="header" href="#712-结构体的泛型">7.1.2 结构体的泛型</a></h4>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T,U&gt; {
    x: T,
    y: U,
}
fn main() {
    let p = Point{x: 1, y :1.1};
}</code></pre></pre>
<h4 id="713-枚举的泛型"><a class="header" href="#713-枚举的泛型">7.1.3 枚举的泛型</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="714-方法的泛型"><a class="header" href="#714-方法的泛型">7.1.4 方法的泛型</a></h4>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}</code></pre></pre>
<h5 id="为具体的泛型类型实现方法"><a class="header" href="#为具体的泛型类型实现方法">为具体的泛型类型实现方法</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="715-const-泛型rust-151-版本引入的重要特性"><a class="header" href="#715-const-泛型rust-151-版本引入的重要特性">7.1.5 const 泛型（Rust 1.51 版本引入的重要特性）</a></h4>
<pre><pre class="playground"><code class="language-rust">// 用数组切片的方式，可以实现 const 泛型
fn display_array&lt;T: std::fmt::Debug&gt;(arr: &amp;[T]) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(&amp;arr);

    let arr: [i32;2] = [1,2];
    display_array(&amp;arr);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// const 泛型，针对usize
fn display_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: [T; N]) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32; 2] = [1, 2];
    display_array(arr);
}</code></pre></pre>
<h3 id="72-特征trait"><a class="header" href="#72-特征trait">7.2 特征trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<h4 id="721-定义特征"><a class="header" href="#721-定义特征">7.2.1 定义特征</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="722-为类型实现特征"><a class="header" href="#722-为类型实现特征">7.2.2 为类型实现特征</a></h4>
<pre><pre class="playground"><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
pub struct Post {
    pub title: String, // 标题
    pub author: String, // 作者
    pub content: String, // 内容
}

impl Summary for Post {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;文章{}, 作者是{}&quot;, self.title, self.author)
    }
}

pub struct Weibo {
    pub username: String,
    pub content: String
}

impl Summary for Weibo {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}发表了微博{}&quot;, self.username, self.content)
    }
}

fn main() {
    let post = Post{title: &quot;Rust语言简介&quot;.to_string(),author: &quot;Sunface&quot;.to_string(), content: &quot;Rust棒极了!&quot;.to_string()};
    let weibo = Weibo{username: &quot;sunface&quot;.to_string(),content: &quot;好像微博没Tweet好用&quot;.to_string()};

    println!(&quot;{}&quot;,post.summarize());
    println!(&quot;{}&quot;,weibo.summarize());
}</code></pre></pre>
<h4 id="723-使用特征作为函数参数"><a class="header" href="#723-使用特征作为函数参数">7.2.3 使用特征作为函数参数</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<h4 id="724-特征约束trait-bound"><a class="header" href="#724-特征约束trait-bound">7.2.4 特征约束(trait bound)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 标准trait bound, 上面的代码impl Summary 是语法糖
pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {}
// 两个参数实现不同的特征，用这种方式实现，比较好。
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {}
// 如果是多参数实现相同的特征，用这种。
<span class="boring">}</span></code></pre></pre>
<h5 id="多重约束"><a class="header" href="#多重约束">多重约束</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;(impl Summary + Display)) {}
// 除了上面的语法糖，还可以使用特征约束
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}
<span class="boring">}</span></code></pre></pre>
<h5 id="where约束"><a class="header" href="#where约束">where约束</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{}
<span class="boring">}</span></code></pre></pre>
<h5 id="使用特征约束有条件地实现方法或特征"><a class="header" href="#使用特征约束有条件地实现方法或特征">使用特征约束有条件地实现方法或特征</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="725-函数返回中的-impl-trait"><a class="header" href="#725-函数返回中的-impl-trait">7.2.5 函数返回中的 impl Trait</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 但是这种返回值方式有一个很大的限制：只能有一个具体的类型
fn returns_summarizable() -&gt; impl Summary {
    Weibo {
        username: String::from(&quot;sunface&quot;),
        content: String::from(
            &quot;m1 max太厉害了，电脑再也不会卡&quot;,
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="726-几个综合例子"><a class="header" href="#726-几个综合例子">7.2.6 几个综合例子</a></h4>
<h5 id="为自定义类型实现--操作"><a class="header" href="#为自定义类型实现--操作">为自定义类型实现 + 操作</a></h5>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

// 为Point结构体派生Debug特征，用于格式化输出
#[derive(Debug)]
struct Point&lt;T: Add&lt;T, Output = T&gt;&gt; { //限制类型T必须实现了Add特征，否则无法进行+操作。
    x: T,
    y: T,
}

impl&lt;T: Add&lt;T, Output = T&gt;&gt; Add for Point&lt;T&gt; {
    type Output = Point&lt;T&gt;;

    fn add(self, p: Point&lt;T&gt;) -&gt; Point&lt;T&gt; {
        Point{
            x: self.x + p.x,
            y: self.y + p.y,
        }
    }
}

fn add&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) -&gt; T {
    a + b
}

fn main() {
    let p1 = Point{x: 1.1f32, y: 1.1f32};
    let p2 = Point{x: 2.1f32, y: 2.1f32};
    println!(&quot;{:?}&quot;, add(p1, p2));

    let p3 = Point{x: 1i32, y: 1i32};
    let p4 = Point{x: 2i32, y: 2i32};
    println!(&quot;{:?}&quot;, add(p3, p4));
}</code></pre></pre>
<h5 id="自定义类型的打印输出"><a class="header" href="#自定义类型的打印输出">自定义类型的打印输出</a></h5>
<pre><pre class="playground"><code class="language-rust">#![allow(dead_code)]

use std::fmt;
use std::fmt::{Display};

#[derive(Debug,PartialEq)]
enum FileState {
  Open,
  Closed,
}

#[derive(Debug)]
struct File {
  name: String,
  data: Vec&lt;u8&gt;,
  state: FileState,
}

impl Display for FileState {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
     match *self {
         FileState::Open =&gt; write!(f, &quot;OPEN&quot;),
         FileState::Closed =&gt; write!(f, &quot;CLOSED&quot;),
     }
   }
}

impl Display for File {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
      write!(f, &quot;&lt;{} ({})&gt;&quot;,
             self.name, self.state)
   }
}

impl File {
  fn new(name: &amp;str) -&gt; File {
    File {
        name: String::from(name),
        data: Vec::new(),
        state: FileState::Closed,
    }
  }
}

fn main() {
  let f6 = File::new(&quot;f6.txt&quot;);
  //...
  println!(&quot;{:?}&quot;, f6);
  println!(&quot;{}&quot;, f6);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="8-集合类型"><a class="header" href="#8-集合类型">8. 集合类型</a></h2>
<h3 id="81-动态数组vector"><a class="header" href="#81-动态数组vector">8.1 动态数组Vector</a></h3>
<h4 id="811-创建动态数组"><a class="header" href="#811-创建动态数组">8.1.1 创建动态数组</a></h4>
<h5 id="vecnew"><a class="header" href="#vecnew">Vec::new</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();

let mut v = Vec::new();
v.push(1);
<span class="boring">}</span></code></pre></pre>
<h5 id="vec"><a class="header" href="#vec"><code>vec![]</code></a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h4 id="812-从vector中读取元素"><a class="header" href="#812-从vector中读取元素">8.1.2 从Vector中读取元素</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

// 通过下标
let third: &amp;i32 = &amp;v[2];
println!(&quot;第三个元素是 {}&quot;, third);

// 通过get方法
match v.get(2) {
    Some(third) =&gt; println!(&quot;第三个元素是 {third}&quot;),
    None =&gt; println!(&quot;去你的第三个元素，根本没有！&quot;),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="813-下标索引与get的区别"><a class="header" href="#813-下标索引与get的区别">8.1.3 下标索引与.get的区别</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];   // 报错
let does_not_exist = v.get(100);    // 有值返回Some, 无值返回None
<span class="boring">}</span></code></pre></pre>
<h4 id="814-同时借用多个数组元素"><a class="header" href="#814-同时借用多个数组元素">8.1.4 同时借用多个数组元素</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 原因在于：数组的大小是可变的，当旧数组的大小不够用时，Rust 会重新分配一块更大的内存空间，然后把旧数组拷贝过来。
// 这种情况下，之前的引用显然会指向一块无效的内存，这非常 rusty —— 对用户进行严格的教育。
//
// 不可变借用可以n个，可变借用只能有一个
let mut v = vec![1, 2, 3, 4, 5];

// 不可变借用
let first = &amp;v[0];

// 可变借用
v.push(6);

// 又一次使用first，报错！
println!(&quot;The first element is: {first}&quot;);
<span class="boring">}</span></code></pre></pre>
<h4 id="815-迭代遍历vector中的元素"><a class="header" href="#815-迭代遍历vector中的元素">8.1.5 迭代遍历Vector中的元素</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
// 遍历不可变借用v
for i in &amp;v {
    println!(&quot;{i}&quot;);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 遍历修改Vector
let mut v = vec![1, 2, 3];
// 遍历可变借用v，因此i是可变借用，类型为&amp;mut i32, 不支持+=
// 需要deref
for i in &amp;mut v {
    *i += 10
}
<span class="boring">}</span></code></pre></pre>
<h4 id="816-存储不同类型的元素"><a class="header" href="#816-存储不同类型的元素">8.1.6 存储不同类型的元素</a></h4>
<pre><pre class="playground"><code class="language-rust">// 数组的元素必须类型相同。
// 解决方案：通过枚举类型和特征类型实现不同元素的存储。
// 枚举类型的实现：
#[derive(Debug)]
enum IpAddr {
    V4(String),
    V6(String)
}
fn main() {
    let v = vec![
        IpAddr::V4(&quot;127.0.0.1&quot;.to_string()),
        IpAddr::V6(&quot;::1&quot;.to_string())
    ];

    for ip in v {
        show_addr(ip)
    }
}

fn show_addr(ip: IpAddr) {
    println!(&quot;{:?}&quot;,ip);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">trait IpAddr {
    fn display(&amp;self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&amp;self) {
        println!(&quot;ipv4: {:?}&quot;,self.0)
    }
}
struct V6(String);
impl IpAddr for V6 {
    fn display(&amp;self) {
        println!(&quot;ipv6: {:?}&quot;,self.0)
    }
}

fn main() {
    // 将实现了特征 IpAddr 的实例，用Box::new()包装
    // 这里必须手动指定类型：Vec&lt;Box&lt;dyn IpAddr&gt;&gt;，表示数组 v 存储的是特征 IpAddr 的对象
    let v: Vec&lt;Box&lt;dyn IpAddr&gt;&gt; = vec![
        Box::new(V4(&quot;127.0.0.1&quot;.to_string())),
        Box::new(V6(&quot;::1&quot;.to_string())),
    ];

    for ip in v {
        ip.display();
    }
}</code></pre></pre>
<h4 id="817-vector的排序"><a class="header" href="#817-vector的排序">8.1.7 Vector的排序</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 稳定的排序 sort 和 sort_by，以及非稳定排序 sort_unstable 和 sort_unstable_by。
// 在 [ 稳定 ] 排序算法里，对相等的元素，不会对其进行重新排序。而在 [ 不稳定 ] 的算法里则不保证这点。
// 总体而言，[ 非稳定 ] 排序的算法的速度会优于 [ 稳定 ] 排序算法，同时，[ 稳定 ] 排序还会额外分配原数组一半的空间。
<span class="boring">}</span></code></pre></pre>
<h5 id="整数数组的排序"><a class="header" href="#整数数组的排序">整数数组的排序</a></h5>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = vec![1, 5, 10, 2, 15];    
    vec.sort_unstable();    
    assert_eq!(vec, vec![1, 2, 5, 10, 15]);
}</code></pre></pre>
<h5 id="浮点数组的排序"><a class="header" href="#浮点数组的排序">浮点数组的排序</a></h5>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut vec = vec![1.0, 5.6, 10.3, 2.0, 15f32];    
    // vec.sort_unstable();
    vec.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());    
    assert_eq!(vec, vec![1.0, 2.0, 5.6, 10.3, 15f32]);
}</code></pre></pre>
<h6 id="partial_cmp"><a class="header" href="#partial_cmp">partial_cmp</a></h6>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果存在，则返回self和other之间的顺序
use std::cmp::Ordering;

let result = 1.0.partial_cmp(&amp;2.0);
assert_eq!(result, Some(Ordering::Less));

let result = 1.0.partial_cmp(&amp;1.0);
assert_eq!(result, Some(Ordering::Equal));

let result = 2.0.partial_cmp(&amp;1.0);
assert_eq!(result, Some(Ordering::Greater));

// 如果不存在，则返回None
let result = f64::NAN.partial_cmp(&amp;1.0);
assert_eq!(result, None);
<span class="boring">}</span></code></pre></pre>
<h5 id="对结构体数组进行排序"><a class="header" href="#对结构体数组进行排序">对结构体数组进行排序</a></h5>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn new(name: String, age: u32) -&gt; Person {
        Person { name, age }
    }
}

fn main() {
    let mut people = vec![
        Person::new(&quot;Zoe&quot;.to_string(), 25),
        Person::new(&quot;Al&quot;.to_string(), 60),
        Person::new(&quot;John&quot;.to_string(), 1),
    ];
    // 定义一个按照年龄倒序排序的对比函数
    people.sort_unstable_by(|a, b| b.age.cmp(&amp;a.age));

    println!(&quot;{:?}&quot;, people);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 实现 Ord 需要我们实现 Ord、Eq、PartialEq、PartialOrd 这些属性。好消息是，你可以 derive 这些属性：
#[derive(Debug, Ord, Eq, PartialEq, PartialOrd)]
struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn new(name: String, age: u32) -&gt; Person {
        Person { name, age }
    }
}

fn main() {
    let mut people = vec![
        Person::new(&quot;Zoe&quot;.to_string(), 25),
        Person::new(&quot;Al&quot;.to_string(), 60),
        Person::new(&quot;Al&quot;.to_string(), 30),
        Person::new(&quot;John&quot;.to_string(), 1),
        Person::new(&quot;John&quot;.to_string(), 25),
    ];

    people.sort_unstable();

    println!(&quot;{:?}&quot;, people);
}
// 需要 derive Ord 相关特性，需要确保你的结构体中所有的属性均实现了 Ord 相关特性，否则会发生编译错误。
// derive 的默认实现会依据属性的顺序依次进行比较，如上述例子中，当 Person 的 name 值相同，则会使用 age 进行比较。</code></pre></pre>
<h3 id="82-kv存储hashmap"><a class="header" href="#82-kv存储hashmap">8.2 KV存储Hashmap</a></h3>
<h4 id="821-创建hashmap"><a class="header" href="#821-创建hashmap">8.2.1 创建Hashmap</a></h4>
<h5 id="使用new方法"><a class="header" href="#使用new方法">使用new方法</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// 创建一个HashMap，用于存储宝石种类和对应的数量
let mut my_gems = HashMap::new();

// 该Hashmap的类型HashMap&lt;&amp;str,i32&gt;
// 将宝石类型和对应的数量写入表中
my_gems.insert(&quot;红宝石&quot;, 1);
my_gems.insert(&quot;蓝宝石&quot;, 2);
my_gems.insert(&quot;河边捡的误以为是宝石的破石头&quot;, 18);
<span class="boring">}</span></code></pre></pre>
<h5 id="使用迭代器和collect方法创建"><a class="header" href="#使用迭代器和collect方法创建">使用迭代器和collect方法创建</a></h5>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use std::collections::HashMap;

    let teams_list = vec![
        (&quot;中国队&quot;.to_string(), 100),
        (&quot;美国队&quot;.to_string(), 10),
        (&quot;日本队&quot;.to_string(), 50),
    ];

    let mut teams_map = HashMap::new();
    for team in &amp;teams_list {
        // teams_list&lt;vec&gt;的第一项是String, HashMap要求是&amp;str, 因此要用&amp;team.0
        teams_map.insert(&amp;team.0, team.1);
    }

    println!(&quot;{:?}&quot;,teams_map)
}

</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use std::collections::HashMap;

    let teams_list = vec![
        (&quot;中国队&quot;.to_string(), 100),
        (&quot;美国队&quot;.to_string(), 10),
        (&quot;日本队&quot;.to_string(), 50),
    ];

    // into_iter()
    // collect() 将迭代器转换为集合
    let teams_map: HashMap&lt;_,_&gt; = teams_list.into_iter().collect();
    
    println!(&quot;{:?}&quot;,teams_map)
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];

let doubled: Vec&lt;i32&gt; = a.iter()
                         .map(|&amp;x| x * 2)
                         .collect();

assert_eq!(vec![2, 4, 6], doubled);
<span class="boring">}</span></code></pre></pre>
<h4 id="822-所有权转移"><a class="header" href="#822-所有权转移">8.2.2 所有权转移</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use std::collections::HashMap;

    let name = String::from(&quot;Sunface&quot;);
    let age = 18;

    let mut handsome_boys = HashMap::new();
    // String 没有实现copy特性,转移所有权
    // 需要复制name, 或者引用，如果引用，就要注意name的lifetime
    handsome_boys.insert(name, age);

    println!(&quot;因为过于无耻，{}已经被从帅气男孩名单中除名&quot;, name);   // name borrowed
    println!(&quot;还有，他的真实年龄远远不止{}岁&quot;, age);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use std::collections::HashMap;

    let name = String::from(&quot;Sunface&quot;);
    let age = 18;

    let mut handsome_boys = HashMap::new();
    // &amp;name 实现了copy特性
    handsome_boys.insert(&amp;name, age);

    std::mem::drop(name);   // 引用的话，要保证所有权比hashmap活的久
    println!(&quot;因为过于无耻，{:?}已经被除名&quot;, handsome_boys);
    println!(&quot;还有，他的真实年龄远远不止{}岁&quot;, age);
}</code></pre></pre>
<h4 id="823-查询hashmap"><a class="header" href="#823-查询hashmap">8.2.3 查询hashmap</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
// get方法获取值
let score: Option&lt;&amp;i32&gt; = scores.get(&amp;team_name);
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

// 遍历
for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="824-更新hashmap"><a class="header" href="#824-更新hashmap">8.2.4 更新hashmap</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(&quot;Blue&quot;, 10);

    // insert() 无键返回None, 存在键值, 更新值，返回旧值。键值不更新。
    // 覆盖已有的值
    let old = scores.insert(&quot;Blue&quot;, 20);
    assert_eq!(old, Some(10));

    // 查询新插入的值
    let new = scores.get(&quot;Blue&quot;);
    assert_eq!(new, Some(&amp;20));

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry(&quot;Yellow&quot;).or_insert(5);
    assert_eq!(*v, 5); // 不存在，插入5

    // 查询Yellow对应的值，若不存在则插入新值
    let v = scores.entry(&quot;Yellow&quot;).or_insert(50);
    assert_eq!(*v, 5); // 已经存在，因此50没有插入
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();
// 根据空格来切分字符串(英文单词都是通过空格切分)
for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0); // or_insert() 值不存在则插入
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut map: HashMap&lt;&amp;str, u32&gt; = HashMap::new();

// and_modify() 在任何潜在的插入 map 之前，提供对占用条目的就地可变访问。
map.entry(&quot;poneyland&quot;)
   .and_modify(|e| { *e += 1 })
   .or_insert(42);
assert_eq!(map[&quot;poneyland&quot;], 42);

map.entry(&quot;poneyland&quot;)
   .and_modify(|e| { *e += 1 })
   .or_insert(42);
assert_eq!(map[&quot;poneyland&quot;], 43);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="9-认识生命周期"><a class="header" href="#9-认识生命周期">9. 认识生命周期</a></h2>
<h3 id="91-悬垂指针和生命周期"><a class="header" href="#91-悬垂指针和生命周期">9.1 悬垂指针和生命周期</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let r;
    {
        // x 活的不够久，r引用了x, 在作用域外被销毁
        let x = 5;
        r = &amp;x;
    }
    println!(&quot;r: {}&quot;, r);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="92-借用检查"><a class="header" href="#92-借用检查">9.2 借用检查</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
<span class="boring">}</span></code></pre></pre>
<h3 id="93-函数中的生命周期"><a class="header" href="#93-函数中的生命周期">9.3 函数中的生命周期</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    // if 需要返回值，无法判断返回的是x或y，因此要明确生命周期
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre></pre>
<h3 id="94-结构体中的生命周期"><a class="header" href="#94-结构体中的生命周期">9.4 结构体中的生命周期</a></h3>
<pre><pre class="playground"><code class="language-rust">// 结构体 ImportantExcerpt 所引用的字符串 str 必须比该结构体活得更久。
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let i;
    {
        let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
        let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
        i = ImportantExcerpt {
            part: first_sentence,
        };
    }
    // 可以看出结构体比它引用的字符串活得更久
    println!(&quot;{:?}&quot;,i);
}</code></pre></pre>
<h3 id="95-生命周期消除"><a class="header" href="#95-生命周期消除">9.5 生命周期消除</a></h3>
<p><strong>引用才有生命周期</strong></p>
<p><strong>三条消除规则</strong></p>
<p>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。</p>
<ul>
<li><strong>每一个引用参数都会获得独自的生命周期</strong></li>
</ul>
<blockquote>
<p>例如一个引用参数的函数就有一个生命周期标注: fn foo&lt;'a&gt;(x: &amp;'a i32)，两个引用参数的有两个生命周期标注:fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32), 依此类推。</p>
</blockquote>
<ul>
<li><strong>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期</strong></li>
</ul>
<blockquote>
<p>例如函数 fn foo(x: &amp;i32) -&gt; &amp;i32，x 参数的生命周期会被自动赋给返回值 &amp;i32，因此该函数等同于 fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</p>
</blockquote>
<ul>
<li><strong>若存在多个输入生命周期，且其中一个是 &amp;self 或 &amp;mut self，则 &amp;self 的生命周期被赋给所有的输出生命周期</strong></li>
</ul>
<blockquote>
<p>拥有 &amp;self 形式的参数，说明该函数是一个 方法，该规则让方法的使用便利度大幅提升。</p>
</blockquote>
<p>规则其实很好理解，但是，爱思考的读者肯定要发问了，例如第三条规则，若一个方法，它的返回值的生命周期就是跟参数 &amp;self 的不一样怎么办？总不能强迫我返回的值总是和 &amp;self 活得一样久吧？! 问得好，答案很简单：手动标注生命周期，因为这些规则只是编译器发现你没有标注生命周期时默认去使用的，当你标注生命周期后，编译器自然会乖乖听你的话。</p>
<h3 id="96-方法中的生命周期"><a class="header" href="#96-方法中的生命周期">9.6 方法中的生命周期</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="97-静态生命周期"><a class="header" href="#97-静态生命周期">9.7 静态生命周期</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 'static，拥有该生命周期的引用可以和整个程序活得一样久。
let s: &amp;'static str = &quot;我没啥优点，就是活得久，嘿嘿&quot;;
<span class="boring">}</span></code></pre></pre>
<h3 id="98-一个复杂的例子-泛型特征约束"><a class="header" href="#98-一个复杂的例子-泛型特征约束">9.8 一个复杂的例子: 泛型，特征约束</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
